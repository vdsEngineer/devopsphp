name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
    paths-ignore:
      - '**.md'           # Любые Markdown файлы (README, CHANGELOG)
      - 'docs/**'         # Папка с документацией (если появится)
      - 'LICENSE'         # Файл лицензии
      - '.gitignore'      # Настройки гита
      - '.editorconfig'   # Настройки IDE
      - '.env.example'    # Пример окружения (обычно не ломает сборку)

  pull_request:
    branches: [ "main" ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'LICENSE'
      - '.gitignore'
      - '.editorconfig'

env:
  IMAGE_NAME: ${{ github.repository }}
  REGISTRY: ghcr.io

jobs:
  # --- ЭТАП 1: ПРОВЕРКА КОДА (Static & Unit) ---
  quality:
    runs-on: ubuntu-latest
    services:
      postgres: # Поднимаем базу для юнит-тестов
        image: postgres:16-alpine
        env:
          POSTGRES_DB: testing_db
          POSTGRES_PASSWORD: password
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:alpine
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4
      
      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: pdo_pgsql, redis, bcmath
      
      - name: Install Dependencies
        run: composer install --prefer-dist --no-progress

      - name: Copy .env
        run: cp .env.example .env

      - name: Generate Key
        run: php artisan key:generate

      - name: Run Pint (Style)
        run: ./vendor/bin/pint --test

      - name: Run PHPStan (Static Analysis)
        run: ./vendor/bin/phpstan analyse --memory-limit=2G

      - name: Run Pest (Unit Tests)
        env:
          DB_CONNECTION: pgsql
          DB_HOST: 127.0.0.1
          DB_PORT: 5432
          DB_DATABASE: testing_db
          DB_USERNAME: postgres
          DB_PASSWORD: password
          REDIS_HOST: 127.0.0.1
        run: php artisan test
 
  # 2. СБОРКА ПРОД-ОБРАЗА
  build-image:
      needs: quality
      runs-on: ubuntu-latest
      outputs:
        image_tag: ${{ steps.meta.outputs.tags }}
      permissions:
        contents: read
        packages: write
      steps:
        - uses: actions/checkout@v4
        
        - name: Lowercase repo name
          shell: bash
          run: |
            IMAGE_NAME_LOWER="$(echo "$GITHUB_REPOSITORY" | tr '[:upper:]' '[:lower:]')"
            echo "IMAGE_NAME_LOWER=$IMAGE_NAME_LOWER" >> "$GITHUB_ENV"

        - name: Set up Docker Buildx
          uses: docker/setup-buildx-action@v3
          with:
            driver: docker-container

        - name: Login to GHCR
          uses: docker/login-action@v3
          with:
            registry: ${{ env.REGISTRY }}
            username: ${{ github.actor }}
            password: ${{ secrets.GITHUB_TOKEN }}

        - name: Build and Push (Temporary Tag)
          uses: docker/build-push-action@v5
          with:
            context: .
            file: docker/Dockerfile
            target: prod 
            push: true
            tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}:ci-${{ github.sha }}
            cache-from: type=gha
            cache-to: type=gha,mode=max
 
  # --- ЭТАП 3: НАГРУЗОЧНЫЙ ТЕСТ (Performance Gate) ---
  performance:
      needs: build-image
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4

        - name: Lowercase repo name
          run: echo "IMAGE_NAME_LOWER=${GITHUB_REPOSITORY,,}" >> ${GITHUB_ENV}

        # 1. СОЗДАЕМ ИЗОЛИРОВАННУЮ СЕТЬ
        - name: Create Network
          run: docker network create ci-net

        # 2. ПОДГОТОВКА .ENV
        - name: Prepare Environment
          run: |
            cp .env.example .env
            echo "APP_KEY=base64:pW+J8J8J8J8J8J8J8J8J8J8J8J8J8J8J8J8J8J8J8J8=" >> .env
            echo "DB_CONNECTION=pgsql" >> .env
            echo "DB_HOST=db" >> .env
            echo "DB_DATABASE=laravel" >> .env
            echo "DB_USERNAME=sail" >> .env
            echo "DB_PASSWORD=password" >> .env
            echo "REDIS_HOST=redis" >> .env
            echo "TELESCOPE_ENABLED=false" >> .env

        # 3. ЗАПУСК ИНФРАСТРУКТУРЫ ЧЕРЕЗ DOCKER RUN (чтобы всё было в одной сети ci-net)
        - name: Start Database
          run: |
            docker run -d --name db --network ci-net \
              -e POSTGRES_DB=laravel -e POSTGRES_USER=sail -e POSTGRES_PASSWORD=password \
              postgres:16-alpine
        
        - name: Start Redis
          run: docker run -d --name redis --network ci-net redis:alpine

        - name: Wait for DB
          run: sleep 20

        # 4. ЗАПУСК МИГРАЦИЙ
        - name: Run Migrations
          run: |
            docker run --rm --network ci-net --env-file .env \
              --entrypoint php \
              ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}:ci-${{ github.sha }} \
              artisan migrate --force

        # 5. ЗАПУСК ПРИЛОЖЕНИЯ
        - name: Start Prod App
          run: |
            # Запускаем контейнер. 
            # Мы добавляем chmod прямо перед стартом внутри, чтобы вылечить ошибки прав
            docker run -d --name app --network ci-net -p 8000:8000 --env-file .env \
              ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_LOWER }}:ci-${{ github.sha }}
            
            # Даем Octane время проснуться
            sleep 15
            
            # ОЧЕНЬ ВАЖНО: Смотрим логи. Если здесь будет ошибка, мы увидим её в GitHub Actions
            docker logs app
            
            # Проверяем, что эндпоинт вообще отвечает
            curl -f http://localhost:8000/ || (docker logs app && exit 1)

        # 6. НАГРУЗОЧНЫЙ ТЕСТ K6
        - name: Run k6
          run: |
            docker run --rm --network ci-net \
              -v ./docker/k6:/scripts \
              grafana/k6 run /scripts/ci.js
 

  # --- ЭТАП 4: СБОРКА И ПУБЛИКАЦИЯ (Build & Push) ---
  promote-to-latest:
    needs: performance
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Tag and Push Latest
        run: |
          IMAGE_NAME_LOWER=$(echo "$GITHUB_REPOSITORY" | tr '[:upper:]' '[:lower:]')
          IMAGE_ID=${{ env.REGISTRY }}/$IMAGE_NAME_LOWER
          docker pull $IMAGE_ID:ci-${{ github.sha }}
          docker tag $IMAGE_ID:ci-${{ github.sha }} $IMAGE_ID:latest
          docker push $IMAGE_ID:latest
  # --- ЭТАП 5: ДЕПЛОЙ НА СЕРВЕР ---
  deploy:
      needs: promote-to-latest # Ждем, пока образ получит тег latest
      runs-on: ubuntu-latest
      steps:
        - name: Deploy to Server
          uses: appleboy/ssh-action@master
          with:
            host: ${{ secrets.SSH_HOST }}
            username: ${{ secrets.SSH_USER }}
            key: ${{ secrets.SSH_PRIVATE_KEY }}
            script: |
              # 1. Логинимся в реестр GitHub
              echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin
              
              # 2. Скачиваем свежий образ
              REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
              IMAGE_URL="ghcr.io/$REPO_LOWER:latest"
              
              docker pull $IMAGE_URL
              
              # 3. Останавливаем старый контейнер (если есть)
              docker stop app-devops || true
              docker rm app-devops || true
              
              docker run -d \
                --name app-devops \
                --network app-network \
                --restart always \
                --cpus="0.4" \
                --memory="300m" \
                -p 8000:8000 \
                -e APP_ENV=production \
                -e APP_DEBUG=false \
                -e APP_KEY=${{ secrets.APP_KEY }} \
                -e DB_CONNECTION=pgsql \
                -e DB_HOST=infra-db \
                -e DB_PORT=5432 \
                -e DB_DATABASE=${{ secrets.DB_DATABASE }} \
                -e DB_USERNAME=${{ secrets.DB_USERNAME }} \
                -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
                -e REDIS_HOST=infra-redis \
                -e RABBITMQ_HOST=infra-rabbitmq \
                -e LOG_CHANNEL=stderr \
                -e OCTANE_WORKERS=1 \
                -e OCTANE_TASK_WORKERS=1 \
                $IMAGE_URL \
                php artisan octane:start --server=frankenphp --host=0.0.0.0 --port=8000 --workers=1 --task-workers=0 --max-requests=250

              # 5. Запускаем WORKER (Очереди)
              docker stop worker-devops || true
              docker rm worker-devops || true
              
              docker run -d \
                --name worker-devops \
                --network app-network \
                --restart always \
                --cpus="0.2" \
                --memory="150m" \
                -e APP_ENV=production \
                -e APP_KEY=${{ secrets.APP_KEY }} \
                -e DB_CONNECTION=pgsql \
                -e DB_HOST=infra-db \
                -e DB_DATABASE=${{ secrets.DB_DATABASE }} \
                -e DB_USERNAME=${{ secrets.DB_USERNAME }} \
                -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \
                -e REDIS_HOST=infra-redis \
                -e RABBITMQ_HOST=infra-rabbitmq \
                -e QUEUE_CONNECTION=rabbitmq \
                -e LOG_CHANNEL=stderr \
                -e OCTANE_WORKERS=1 \
                -e OCTANE_TASK_WORKERS=1 \
                $IMAGE_URL \
                php artisan queue:work --tries=1 --timeout=90  --memory=100

              # 6. Чистим старые образы (чтобы не забить диск)
              docker image prune -f